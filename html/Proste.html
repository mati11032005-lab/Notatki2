<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Geometria 3D - Analiza Relacji</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script>
        MathJax = { tex: { inlineMath: [['$', '$']] }, svg: { fontCache: 'global' } };
    </script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <style>
        :root {
            --bg: #0f172a; --panel: #1e293b; --input: #334155;
            --text: #f1f5f9; --accent: #0ea5e9; --success: #22c55e;
        }
        body { font-family: 'Inter', sans-serif; margin: 0; background: var(--bg); color: var(--text); height: 100vh; display: flex; overflow: hidden; }
        
        /* Sidebar */
        .sidebar { width: 420px; background: var(--panel); padding: 15px; overflow-y: auto; box-shadow: 4px 0 15px rgba(0,0,0,0.5); display: flex; flex-direction: column; gap: 15px; }
        h2 { font-size: 1.2rem; margin: 0; text-align: center; color: var(--accent); }
        
        .tabs { display: flex; gap: 4px; background: var(--bg); padding: 4px; border-radius: 8px; }
        .tab-btn { flex: 1; padding: 8px 2px; border: none; background: transparent; color: #94a3b8; cursor: pointer; border-radius: 6px; font-weight: 600; font-size: 0.75rem; transition: 0.2s; }
        .tab-btn.active { background: var(--accent); color: white; }

        /* Kompaktowe Inputy */
        .input-group { background: rgba(255,255,255,0.02); padding: 12px; border-radius: 8px; border: 1px solid #334155; }
        .input-group h3 { margin: 0 0 8px 0; font-size: 0.85rem; color: var(--accent); display: flex; justify-content: space-between; }
        
        .compact-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 6px; margin-bottom: 8px; }
        .param-box { display: flex; align-items: center; background: var(--input); border-radius: 4px; padding: 2px 6px; border: 1px solid #475569; }
        .param-label { font-size: 0.7rem; font-weight: bold; color: var(--accent); margin-right: 5px; min-width: 12px; }
        input { background: transparent; border: none; color: white; width: 100%; font-size: 0.8rem; text-align: center; outline: none; }

        /* Analiza */
        .analysis { background: #0c111d; padding: 15px; border-radius: 8px; border-left: 4px solid var(--accent); margin-top: auto; }
        .status-badge { display: inline-block; padding: 3px 12px; border-radius: 12px; font-size: 0.75rem; font-weight: bold; margin-bottom: 8px; background: var(--accent); color: white; }
        .explanation { font-size: 0.85rem; line-height: 1.4; color: #cbd5e1; }
        .math-logic { margin-top: 10px; padding-top: 10px; border-top: 1px solid #334155; font-family: 'serif'; font-size: 0.9rem; }

        /* Wykres */
        .viewer { flex-grow: 1; }
        #plot { width: 100%; height: 100%; }
    </style>
</head>
<body>

<div class="sidebar">
    <h2>Geometria Analityczna 3D</h2>
    <div class="tabs">
        <button class="tab-btn active" onclick="switchTab('ll')">Prosta & Prosta</button>
        <button class="tab-btn" onclick="switchTab('pp')">Płaszcz. & Płaszcz.</button>
        <button class="tab-btn" onclick="switchTab('lp')">Prosta & Płaszcz.</button>
    </div>

    <div id="inputs-container"></div>

    <div class="analysis">
        <div id="rel-status" class="status-badge">Obliczanie...</div>
        <div id="rel-calc" class="explanation"></div>
        <div id="math-details" class="math-logic"></div>
    </div>
</div>

<div class="viewer">
    <div id="plot"></div>
</div>

<script>
    let currentTab = 'll';
    const params = {
        l1: { px: 0, py: 0, pz: 0, vx: 1, vy: 0, vz: 0 },
        l2: { px: 0, py: 1, pz: 0, vx: 0, vy: 1, vz: 0 },
        pl1: { a: 0, b: 0, c: 1, d: 0 },
        pl2: { a: 0, b: 1, c: 0, d: 0 }
    };

    function switchTab(tab) {
        currentTab = tab;
        document.querySelectorAll('.tab-btn').forEach(b => b.classList.remove('active'));
        const btn = [...document.querySelectorAll('.tab-btn')].find(b => b.innerText.toLowerCase().includes(tab === 'll' ? 'prosta & prosta' : tab === 'pp' ? 'płaszcz' : 'prosta & płaszcz'));
        if(btn) btn.classList.add('active');
        renderInputs();
        update();
    }

    function renderInputs() {
        const container = document.getElementById('inputs-container');
        let html = '';
        if (currentTab === 'll' || currentTab === 'lp') html += createVectorInput('Prosta $L_1$', 'l1');
        if (currentTab === 'll') html += createVectorInput('Prosta $L_2$', 'l2');
        if (currentTab === 'pp' || currentTab === 'lp') html += createPlaneInput('Płaszczyzna $\\pi_1$', 'pl1');
        if (currentTab === 'pp') html += createPlaneInput('Płaszczyzna $\\pi_2$', 'pl2');
        container.innerHTML = html;
    }

    function createVectorInput(title, key) {
        return `<div class="input-group"><h3>${title}</h3>
            <div class="compact-grid">
                <div class="param-box"><span class="param-label">Px</span><input type="number" value="${params[key].px}" oninput="updateParam('${key}','px',this.value)"></div>
                <div class="param-box"><span class="param-label">Py</span><input type="number" value="${params[key].py}" oninput="updateParam('${key}','py',this.value)"></div>
                <div class="param-box"><span class="param-label">Pz</span><input type="number" value="${params[key].pz}" oninput="updateParam('${key}','pz',this.value)"></div>
            </div>
            <div class="compact-grid">
                <div class="param-box"><span class="param-label">Vx</span><input type="number" value="${params[key].vx}" oninput="updateParam('${key}','vx',this.value)"></div>
                <div class="param-box"><span class="param-label">Vy</span><input type="number" value="${params[key].vy}" oninput="updateParam('${key}','vy',this.value)"></div>
                <div class="param-box"><span class="param-label">Vz</span><input type="number" value="${params[key].vz}" oninput="updateParam('${key}','vz',this.value)"></div>
            </div></div>`;
    }

    function createPlaneInput(title, key) {
        return `<div class="input-group"><h3>${title}</h3>
            <div class="compact-grid" style="grid-template-columns: repeat(4, 1fr)">
                <div class="param-box"><span class="param-label">A</span><input type="number" value="${params[key].a}" oninput="updateParam('${key}','a',this.value)"></div>
                <div class="param-box"><span class="param-label">B</span><input type="number" value="${params[key].b}" oninput="updateParam('${key}','b',this.value)"></div>
                <div class="param-box"><span class="param-label">C</span><input type="number" value="${params[key].c}" oninput="updateParam('${key}','c',this.value)"></div>
                <div class="param-box"><span class="param-label">D</span><input type="number" value="${params[key].d}" oninput="updateParam('${key}','d',this.value)"></div>
            </div></div>`;
    }

    function updateParam(obj, p, val) {
        params[obj][p] = parseFloat(val) || 0;
        update();
    }

    function dot(v1, v2) { return v1[0]*v2[0] + v1[1]*v2[1] + v1[2]*v2[2]; }
    function cross(v1, v2) { return [v1[1]*v2[2]-v1[2]*v2[1], v1[2]*v2[0]-v1[0]*v2[2], v1[0]*v2[1]-v1[1]*v2[0]]; }
    function length(v) { return Math.sqrt(v[0]**2 + v[1]**2 + v[2]**2); }

    function update() {
        let status = "", desc = "", math = "";
        const data = [];

        if (currentTab === 'll') {
            const { l1, l2 } = params;
            const v1 = [l1.vx, l1.vy, l1.vz], v2 = [l2.vx, l2.vy, l2.vz];
            const cp = cross(v1, v2);
            const isParallel = length(cp) < 0.001;
            const p1p2 = [l2.px-l1.px, l2.py-l1.py, l2.pz-l1.pz];
            const dotPerp = dot(v1, v2);

            if (isParallel) {
                const cpDist = length(cross(p1p2, v1));
                if (cpDist < 0.001) {
                    status = "Pokrywają się";
                    desc = "Proste mają ten sam kierunek i wspólne punkty.";
                    math = "$\\vec{v_1} \\times \\vec{v_2} = \\vec{0}$ oraz $\\vec{P_1P_2} \\times \\vec{v_1} = \\vec{0}$";
                } else {
                    status = "Równoległe";
                    desc = "Proste biegną w tym samym kierunku, ale nie mają punktów wspólnych.";
                    math = "$\\vec{v_1} \\times \\vec{v_2} = \\vec{0}$, ale $\\vec{P_1P_2} \\times \\vec{v_1} \\neq \\vec{0}$";
                }
            } else {
                const mixedProduct = dot(p1p2, cp);
                if (Math.abs(mixedProduct) < 0.001) {
                    status = (Math.abs(dotPerp) < 0.001) ? "Przecinające się (Prostopadłe)" : "Przecinające się";
                    desc = "Proste leżą w jednej płaszczyźnie i mają jeden punkt wspólny.";
                    math = `Iloczyn mieszany $[\\vec{P_1P_2}, \\vec{v_1}, \\vec{v_2}] = 0$. ${Math.abs(dotPerp) < 0.001 ? "$\\vec{v_1} \\cdot \\vec{v_2} = 0$ (Prostopadłość)" : ""}`;
                } else {
                    status = "Skośne";
                    desc = "Proste nie są równoległe i nie leżą w jednej płaszczyźnie.";
                    math = "Iloczyn mieszany $\\neq 0$ (brak wspólnej płaszczyzny).";
                }
            }
            data.push(getLineTrace(l1, 'Prosta 1', '#f87171'), getLineTrace(l2, 'Prosta 2', '#fbbf24'));

        } else if (currentTab === 'pp') {
            const { pl1, pl2 } = params;
            const n1 = [pl1.a, pl1.b, pl1.c], n2 = [pl2.a, pl2.b, pl2.c];
            const cp = cross(n1, n2);
            const isParallel = length(cp) < 0.001;
            const dotPerp = dot(n1, n2);

            if (isParallel) {
                const isCoincident = Math.abs(pl1.a*pl2.d - pl2.a*pl1.d) < 0.01 && Math.abs(pl1.b*pl2.d - pl2.b*pl1.d) < 0.01;
                status = isCoincident ? "Pokrywają się" : "Równoległe";
                desc = isCoincident ? "Oba równania opisują tę samą przestrzeń." : "Płaszczyzny nigdy się nie spotkają.";
                math = "$\\vec{n_1} \\times \\vec{n_2} = \\vec{0}$ (Wektory normalne są proporcjonalne).";
            } else {
                status = (Math.abs(dotPerp) < 0.001) ? "Przecinające się (Prostopadłe)" : "Przecinające się";
                desc = "Płaszczyzny przecinają się wzdłuż linii prostej.";
                math = Math.abs(dotPerp) < 0.001 ? "$\\vec{n_1} \\cdot \\vec{n_2} = 0$ (Wektory normalne są prostopadłe)." : "$\\vec{n_1} \\times \\vec{n_2} \\neq \\vec{0}$";
            }
            data.push(getPlaneTrace(pl1, 'Płaszcz. 1', 'Blues'), getPlaneTrace(pl2, 'Płaszcz. 2', 'Reds'));

        } else if (currentTab === 'lp') {
            const { l1, pl1 } = params;
            const v = [l1.vx, l1.vy, l1.vz], n = [pl1.a, pl1.b, pl1.c];
            const dotProduct = dot(v, n);
            const pointVal = pl1.a*l1.px + pl1.b*l1.py + pl1.c*l1.pz + pl1.d;

            if (Math.abs(dotProduct) < 0.001) {
                const onPlane = Math.abs(pointVal) < 0.001;
                status = onPlane ? "Zawarta w płaszczyźnie" : "Równoległa";
                desc = onPlane ? "Każdy punkt prostej należy do płaszczyzny." : "Prosta leży w stałej odległości od płaszczyzny.";
                math = "$\\vec{v} \\cdot \\vec{n} = 0$ (Wektor kierunkowy prostopadły do normalnej).";
            } else {
                const isPerp = length(cross(v, n)) < 0.001;
                status = isPerp ? "Przecina (Prostopadła)" : "Przecina";
                desc = "Prosta przebija płaszczyznę w jednym punkcie.";
                math = isPerp ? "$\\vec{v} \\times \\vec{n} = \\vec{0}$ (Wektor kierunkowy równoległy do normalnej)." : "$\\vec{v} \\cdot \\vec{n} \\neq 0$";
            }
            data.push(getLineTrace(l1, 'Prosta', '#f87171'), getPlaneTrace(pl1, 'Płaszczyzna', 'Greens'));
        }

        document.getElementById('rel-status').innerText = status;
        document.getElementById('rel-calc').innerText = desc;
        document.getElementById('math-details').innerHTML = math;
        Plotly.react('plot', data, getLayout());
        if(window.MathJax) MathJax.typeset();
    }

    function getLineTrace(l, name, color) {
        const t = 20;
        return {
            type: 'scatter3d', mode: 'lines', name: name,
            x: [l.px - l.vx*t, l.px + l.vx*t], y: [l.py - l.vy*t, l.py + l.vy*t], z: [l.pz - l.vz*t, l.pz + l.vz*t],
            line: { width: 5, color: color }
        };
    }

    function getPlaneTrace(p, name, colorscale) {
        let x = [], y = [], z = [];
        const size = 10, step = 2;
        for(let i = -size; i <= size; i+=step) {
            let rowX = [], rowY = [], rowZ = [];
            for(let j = -size; j <= size; j+=step) {
                rowX.push(i); rowY.push(j);
                if (Math.abs(p.c) > 0.01) rowZ.push(-(p.a*i + p.b*j + p.d)/p.c);
                else if (Math.abs(p.b) > 0.01) { rowY[rowY.length-1] = -(p.a*i + p.c*j + p.d)/p.b; rowZ.push(j); }
                else { rowX[rowX.length-1] = -(p.b*i + p.c*j + p.d)/p.a; rowY[rowY.length-1] = i; rowZ.push(j); }
            }
            x.push(rowX); y.push(rowY); z.push(rowZ);
        }
        return { type: 'surface', x:x, y:y, z:z, name:name, colorscale:colorscale, opacity:0.5, showscale:false };
    }

    function getLayout() {
        return {
            paper_bgcolor: '#0f172a', plot_bgcolor: '#0f172a',
            scene: {
                xaxis: { gridcolor: '#1e293b', color: '#64748b' },
                yaxis: { gridcolor: '#1e293b', color: '#64748b' },
                zaxis: { gridcolor: '#1e293b', color: '#64748b' }
            },
            margin: { l:0, r:0, b:0, t:0 }, showlegend: false
        };
    }

    renderInputs();
    update();
</script>
</body>
</html>