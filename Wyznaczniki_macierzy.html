<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wizualizacja Laplace'a - Pełna Rekurencja</title>
    <style>
        :root {
            --depth-1-color: #2c3e50; /* Główny poziom (np. 4x4) */
            --depth-2-color: #e67e22; /* Podpoziom (np. 3x3) */
            --depth-3-color: #27ae60; /* Najniższy (2x2) */
            --bg-color: #f4f7f6;
        }

        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; background: var(--bg-color); padding: 20px; line-height: 1.5; color: #333; }
        .container { max-width: 1100px; margin: 0 auto; background: white; padding: 30px; border-radius: 15px; box-shadow: 0 5px 20px rgba(0,0,0,0.1); }
        h1 { text-align: center; color: var(--depth-1-color); margin-bottom: 5px; }
        p.subtitle { text-align: center; color: #7f8c8d; margin-bottom: 30px; }

        /* Panel sterowania */
        .controls { display: flex; justify-content: center; gap: 15px; margin-bottom: 25px; background: #ecf0f1; padding: 15px; border-radius: 10px; }
        input[type="number"] { width: 60px; padding: 8px; border: 1px solid #bdc3c7; border-radius: 5px; text-align: center; font-weight: bold; }
        button { padding: 10px 20px; border: none; border-radius: 5px; cursor: pointer; font-weight: 600; transition: 0.2s; color: white; }
        .btn-gen { background-color: #34495e; }
        .btn-calc { background-color: #2980b9; }
        button:hover { opacity: 0.9; transform: translateY(-1px); }

        /* Siatka macierzy do wpisywania */
        .matrix-grid { display: grid; gap: 8px; justify-content: center; margin: 20px auto; }
        .matrix-input { width: 50px; height: 50px; text-align: center; font-size: 1.1rem; border: 2px solid #dfe6e9; border-radius: 8px; transition: 0.2s; }
        .matrix-input:focus { border-color: #3498db; outline: none; background: #ebf5ff; }

        /* WIZUALIZACJA KROKÓW */
        #output { margin-top: 30px; }
        
        .step-box {
            margin: 15px 0;
            padding: 15px;
            border-left: 5px solid #ccc;
            background: #fff;
            border-radius: 4px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.05);
            position: relative;
        }

        /* Kolorowanie poziomów zagnieżdżenia */
        .depth-1 { border-left-color: var(--depth-1-color); background: #fff; border: 1px solid #e0e0e0; border-left-width: 6px; }
        .depth-2 { border-left-color: var(--depth-2-color); background: #fffdf5; margin-left: 20px; border: 1px solid #ffeebb; border-left-width: 6px;}
        .depth-3 { border-left-color: var(--depth-3-color); background: #f0fff4; margin-left: 40px; border: 1px solid #c3e6cb; border-left-width: 6px;}

        /* Wyświetlanie macierzy w krokach */
        .matrix-view { 
            display: inline-block; 
            vertical-align: top;
            background: white;
            padding: 5px 10px;
            border-radius: 5px;
            border: 1px solid #ccc;
            font-family: monospace;
            font-size: 1.1rem;
            margin: 10px 0;
            position: relative;
        }
        
        /* Ozdobniki nawiasów macierzy */
        .matrix-view::before, .matrix-view::after {
            content: ""; position: absolute; top: 0; bottom: 0; width: 6px; border: 2px solid #000;
        }
        .matrix-view::before { left: -2px; border-right: none; }
        .matrix-view::after { right: -2px; border-left: none; }

        .row-display { padding: 2px 0; }
        .cell-display { display: inline-block; width: 35px; text-align: center; }

        /* Podświetlenia */
        .highlight-bg { background-color: #fff3cd; font-weight: bold; color: #d35400; border-radius: 3px; } /* Wybrany wiersz/kolumna */
        .highlight-cell { background-color: #2980b9; color: white; border-radius: 50%; width: 30px; height: 30px; line-height: 30px; display: inline-block;} /* Aktualnie liczony element */

        .formula { font-weight: bold; color: #c0392b; }
        .result-tag { display: inline-block; padding: 2px 8px; background: #2ecc71; color: white; border-radius: 4px; font-size: 0.9em; margin-left: 10px; }
        .zero-skip { color: #95a5a6; font-style: italic; font-size: 0.9em; margin-left: 20px;}
        
        .header-info { font-weight: bold; margin-bottom: 5px; display: block; }
        .depth-label { 
            font-size: 0.75rem; text-transform: uppercase; letter-spacing: 1px; color: #7f8c8d; 
            margin-bottom: 5px; display: block; border-bottom: 1px solid #eee; padding-bottom: 2px;
        }

    </style>
</head>
<body>

<div class="container">
    <h1>Kalkulator Wyznaczników</h1>
    <p class="subtitle">Wizualizacja Laplace'a: 4x4 &rarr; 3x3 &rarr; 2x2</p>

    <div class="controls">
        <label>Wymiar N:</label>
        <input type="number" id="size" value="4" min="2" max="5">
        <button class="btn-gen" onclick="generateGrid()">Generuj Macierz</button>
        <button class="btn-calc" onclick="calculateDeterminant()">OBLICZ I ROZPISZ</button>
    </div>

    <div id="grid-container" class="matrix-grid"></div>
    <div id="output"></div>
</div>

<script>
    // --- 1. Generowanie i Pobieranie Danych ---

    function generateGrid() {
        const n = parseInt(document.getElementById('size').value);
        const container = document.getElementById('grid-container');
        container.innerHTML = '';
        container.style.gridTemplateColumns = `repeat(${n}, 50px)`;

        for (let i = 0; i < n * n; i++) {
            const input = document.createElement('input');
            input.type = 'number';
            input.className = 'matrix-input';
            input.value = Math.floor(Math.random() * 4); // Domyślnie losowe 0-3
            input.dataset.r = Math.floor(i / n);
            input.dataset.c = i % n;
            container.appendChild(input);
        }
        document.getElementById('output').innerHTML = '';
    }

    function getMatrixFromGrid() {
        const n = parseInt(document.getElementById('size').value);
        const inputs = document.querySelectorAll('.matrix-input');
        let matrix = Array.from({ length: n }, () => Array(n).fill(0));
        inputs.forEach(inp => {
            const r = parseInt(inp.dataset.r);
            const c = parseInt(inp.dataset.c);
            matrix[r][c] = parseFloat(inp.value) || 0;
        });
        return matrix;
    }

    // --- 2. Logika Matematyczna ---

    // Znajduje linię z NAJWIĘKSZĄ ilością zer
    function findBestLine(matrix) {
        let n = matrix.length;
        let best = { type: 'row', index: 0, zeros: -1 };

        // Skanuj wiersze
        for (let i = 0; i < n; i++) {
            let zeros = matrix[i].filter(x => x === 0).length;
            if (zeros > best.zeros) {
                best = { type: 'row', index: i, zeros: zeros };
            }
        }

        // Skanuj kolumny
        for (let j = 0; j < n; j++) {
            let zeros = 0;
            for (let i = 0; i < n; i++) if (matrix[i][j] === 0) zeros++;
            
            // Jeśli kolumna ma więcej zer (lub tyle samo - można zmienić priorytet), bierzemy kolumnę
            if (zeros > best.zeros) {
                best = { type: 'col', index: j, zeros: zeros };
            }
        }
        return best;
    }

    function getMinor(matrix, r, c) {
        return matrix
            .filter((_, idx) => idx !== r)
            .map(row => row.filter((_, idx) => idx !== c));
    }

    // --- 3. Generowanie HTML dla Macierzy ---

    function renderMatrixHTML(matrix, highlightType = null, highlightIndex = -1, currentCell = null) {
        let html = '<div class="matrix-view">';
        for (let i = 0; i < matrix.length; i++) {
            html += '<div class="row-display">';
            for (let j = 0; j < matrix[i].length; j++) {
                let classes = 'cell-display';
                
                // Podświetlenie całego wiersza/kolumny
                if (highlightType === 'row' && i === highlightIndex) classes += ' highlight-bg';
                if (highlightType === 'col' && j === highlightIndex) classes += ' highlight-bg';

                // Podświetlenie konkretnego elementu przetwarzanego
                if (currentCell && currentCell.r === i && currentCell.c === j) {
                    classes = 'cell-display highlight-cell'; 
                }

                html += `<span class="${classes}">${matrix[i][j]}</span>`;
            }
            html += '</div>';
        }
        html += '</div>';
        return html;
    }

    // --- 4. Główna Funkcja Rekurencyjna ---

    function solveLaplace(matrix, depth = 1) {
        const n = matrix.length;

        // BAZA REKURENCJI: Macierz 2x2
        if (n === 2) {
            const a = matrix[0][0], b = matrix[0][1];
            const c = matrix[1][0], d = matrix[1][1];
            const det = a * d - b * c;
            
            return {
                val: det,
                html: `<div class="step-box depth-${depth}">
                        <span class="depth-label">Poziom 2x2</span>
                        <div style="display:flex; align-items:center; gap:20px;">
                            ${renderMatrixHTML(matrix)}
                            <div>
                                <b>Wzór:</b> (${a} &middot; ${d}) - (${b} &middot; ${c})<br>
                                <b>Wynik:</b> ${det}
                            </div>
                        </div>
                       </div>`
            };
        }

        // KROK REKURENCYJNY: N > 2
        const best = findBestLine(matrix);
        
        let htmlBuffer = `<div class="step-box depth-${depth}">`;
        htmlBuffer += `<span class="depth-label">Macierz ${n}x${n}</span>`;
        htmlBuffer += `<div class="header-info">Analiza zer: Wybieram <b>${best.type === 'row' ? 'wiersz' : 'kolumnę'} nr ${best.index + 1}</b> (ilość zer: ${best.zeros})</div>`;
        htmlBuffer += renderMatrixHTML(matrix, best.type, best.index);
        htmlBuffer += `<div style="margin-top:10px;">Rozwijamy względem zaznaczonej linii:</div>`;

        let totalDet = 0;

        // Iteracja po elementach wybranej linii
        for (let k = 0; k < n; k++) {
            let r = best.type === 'row' ? best.index : k;
            let c = best.type === 'row' ? k : best.index;
            let val = matrix[r][c];
            let sign = Math.pow(-1, r + c); // 1 lub -1
            let signChar = sign > 0 ? '+' : '-';

            // Optymalizacja zer
            if (val === 0) {
                htmlBuffer += `<div style="margin: 5px 0 5px 20px;" class="zero-skip">&bull; Element a[${r+1},${c+1}] to 0. Pomijam.</div>`;
                continue;
            }

            // Obliczanie minora
            let minorMatrix = getMinor(matrix, r, c);
            
            htmlBuffer += `<div style="margin-top: 15px; border-top: 1px dashed #ccc; padding-top:10px;">`;
            htmlBuffer += `<b>KROK:</b> Element <b>${val}</b> (pozycja [${r+1},${c+1}], znak z szachownicy: <b>${signChar}</b>)`;
            htmlBuffer += ` &rarr; Liczymy podwyznacznik macierzy ${n-1}x${n-1}:`;
            
            // >>> REKURENCJA <<<
            // Tutaj następuje "wejście głębiej". Jeśli jesteśmy w 4x4, to wywoła solveLaplace dla 3x3.
            let subResult = solveLaplace(minorMatrix, depth + 1);
            
            // Dodajemy HTML wygenerowany przez podwyznacznik do naszego HTML
            htmlBuffer += subResult.html;

            let stepContribution = sign * val * subResult.val;
            totalDet += stepContribution;

            htmlBuffer += `<div style="text-align:right; margin-top:5px;">
                Wkład tego elementu: <span class="formula">${signChar}1 * ${val} * (${subResult.val})</span> = <b>${stepContribution}</b>
            </div>`;
            htmlBuffer += `</div>`; // Koniec bloku kroku
        }

        htmlBuffer += `<div style="margin-top:15px; padding-top:10px; border-top: 2px solid #333; font-size:1.1em;">
            Suma wyznacznika ${n}x${n}: <b>${totalDet}</b>
        </div>`;
        htmlBuffer += `</div>`; // Koniec step-box

        return { val: totalDet, html: htmlBuffer };
    }

    // --- 5. Uruchomienie ---

    function calculateDeterminant() {
        const matrix = getMatrixFromGrid();
        const outputDiv = document.getElementById('output');
        
        outputDiv.innerHTML = '<h3 style="text-align:center">Szczegółowe Rozwiązanie:</h3>';
        
        const result = solveLaplace(matrix, 1); // Startujemy z głębokości 1
        
        outputDiv.innerHTML += result.html;
        
        // Wynik końcowy na dole
        const finalBox = document.createElement('div');
        finalBox.style = "background: #2c3e50; color: white; padding: 20px; text-align: center; font-size: 1.5rem; margin-top: 30px; border-radius: 8px;";
        finalBox.innerHTML = `OSTATECZNY WYNIK: <b>${result.val}</b>`;
        outputDiv.appendChild(finalBox);
    }

    // Start
    generateGrid();

</script>

</body>
</html>