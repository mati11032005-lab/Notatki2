<!DOCTYPE html>
<html lang="pl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Symulator Rzutu Ukośnego</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background-color: #f0f2f5;
            color: #333;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin: 0;
            padding: 20px;
        }

        h1 {
            color: #2c3e50;
        }

        .container {
            display: flex;
            flex-wrap: wrap;
            gap: 20px;
            max-width: 1000px;
            width: 100%;
            background: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }

        .controls {
            flex: 1;
            min-width: 250px;
            padding-right: 20px;
            border-right: 1px solid #eee;
        }

        .canvas-container {
            flex: 2;
            display: flex;
            justify-content: center;
            align-items: center;
            position: relative;
        }

        canvas {
            border: 1px solid #ccc;
            background-color: #fff;
            border-radius: 4px;
            cursor: crosshair;
        }

        .control-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            margin-bottom: 5px;
            font-weight: 600;
            font-size: 0.9em;
        }

        input[type="range"] {
            width: 100%;
            cursor: pointer;
        }

        .value-display {
            float: right;
            color: #007bff;
        }

        button {
            width: 100%;
            padding: 10px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 5px;
            font-size: 1em;
            cursor: pointer;
            transition: background 0.3s;
            margin-top: 10px;
        }

        button:hover {
            background-color: #0056b3;
        }

        button.reset {
            background-color: #6c757d;
        }

        button.reset:hover {
            background-color: #545b62;
        }

        .stats {
            margin-top: 20px;
            padding: 10px;
            background: #e9ecef;
            border-radius: 5px;
            font-size: 0.9em;
        }

        .stats p {
            margin: 5px 0;
        }
    </style>
</head>
<body>

    <h1>Symulator Rzutu Ukośnego</h1>

    <div class="container">
        <div class="controls">
            <h3>Parametry</h3>
            
            <div class="control-group">
                <label>Prędkość początkowa (v₀): <span id="val-v" class="value-display">50 m/s</span></label>
                <input type="range" id="input-v" min="1" max="100" value="50">
            </div>

            <div class="control-group">
                <label>Kąt rzutu (α): <span id="val-angle" class="value-display">45°</span></label>
                <input type="range" id="input-angle" min="0" max="90" value="45">
            </div>

            <div class="control-group">
                <label>Wysokość początkowa (h): <span id="val-h" class="value-display">0 m</span></label>
                <input type="range" id="input-h" min="0" max="100" value="0">
            </div>

            <div class="control-group">
                <label>Grawitacja (g): <span id="val-g" class="value-display">9.81 m/s²</span></label>
                <input type="range" id="input-g" min="1" max="20" step="0.1" value="9.81">
            </div>

            <button id="btn-start">Start Animacji</button>
            <button id="btn-reset" class="reset">Resetuj</button>

            <div class="stats">
                <strong>Wyniki (teoretyczne):</strong>
                <p>Zasięg (Z): <span id="stat-range">-</span></p>
                <p>Maks. wysokość (H): <span id="stat-height">-</span></p>
                <p>Czas lotu (t): <span id="stat-time">-</span></p>
            </div>
        </div>

        <div class="canvas-container">
            <canvas id="simCanvas" width="600" height="400"></canvas>
        </div>
    </div>

    <script>
        const canvas = document.getElementById('simCanvas');
        const ctx = canvas.getContext('2d');

        // Elementy UI
        const inputs = {
            v: document.getElementById('input-v'),
            angle: document.getElementById('input-angle'),
            h: document.getElementById('input-h'),
            g: document.getElementById('input-g')
        };
        const displays = {
            v: document.getElementById('val-v'),
            angle: document.getElementById('val-angle'),
            h: document.getElementById('val-h'),
            g: document.getElementById('val-g')
        };
        const stats = {
            range: document.getElementById('stat-range'),
            height: document.getElementById('stat-height'),
            time: document.getElementById('stat-time')
        };
        
        // Stan symulacji
        let state = {
            running: false,
            t: 0,
            x: 0,
            y: 0,
            path: []
        };
        
        let animationId;
        const scale = 4; // 1 metr = 4 piksele (zoom)

        // Główna funkcja aktualizująca UI i rysująca stan początkowy
        function updateUI() {
            displays.v.innerText = inputs.v.value + " m/s";
            displays.angle.innerText = inputs.angle.value + "°";
            displays.h.innerText = inputs.h.value + " m";
            displays.g.innerText = inputs.g.value + " m/s²";
            
            if (!state.running) {
                drawScene();
                calculateStats();
            }
        }

        // Fizyka: Obliczanie statystyk teoretycznych
        function calculateStats() {
            const v0 = parseFloat(inputs.v.value);
            const angleRad = parseFloat(inputs.angle.value) * (Math.PI / 180);
            const h = parseFloat(inputs.h.value);
            const g = parseFloat(inputs.g.value);

            const vy = v0 * Math.sin(angleRad);
            const vx = v0 * Math.cos(angleRad);

            // Czas lotu (rozwiązanie równania kwadratowego dla y(t) = 0)
            // -0.5gt^2 + vy*t + h = 0
            const delta = (vy * vy) - (4 * (-0.5 * g) * h);
            let time = 0;
            if (delta >= 0) {
                time = (-vy - Math.sqrt(delta)) / (-g); // Wybieramy dodatnie rozwiązanie
            }

            const range = vx * time;
            
            // Maksymalna wysokość
            // t_max_h = vy / g
            const t_h = vy / g;
            const maxHeight = h + (vy * t_h) - (0.5 * g * t_h * t_h);

            stats.range.innerText = range.toFixed(2) + " m";
            stats.height.innerText = maxHeight.toFixed(2) + " m";
            stats.time.innerText = time.toFixed(2) + " s";
        }

        // Rysowanie tła, osi i piłki
        function drawScene() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Rysuj osie
            ctx.beginPath();
            ctx.strokeStyle = '#aaa';
            ctx.lineWidth = 1;
            // Oś X (podłoga)
            ctx.moveTo(0, canvas.height - 20);
            ctx.lineTo(canvas.width, canvas.height - 20);
            // Oś Y
            ctx.moveTo(20, 0);
            ctx.lineTo(20, canvas.height);
            ctx.stroke();

            // Rysuj ścieżkę (jeśli istnieje)
            if (state.path.length > 0) {
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(0, 123, 255, 0.5)';
                ctx.lineWidth = 2;
                ctx.moveTo(20 + state.path[0].x * scale, canvas.height - 20 - state.path[0].y * scale);
                for (let p of state.path) {
                    ctx.lineTo(20 + p.x * scale, canvas.height - 20 - p.y * scale);
                }
                ctx.stroke();
            }

            // Oblicz aktualną pozycję dla podglądu (lub z animacji)
            let posX, posY;
            if (state.running) {
                posX = state.x;
                posY = state.y;
            } else {
                // Pozycja startowa
                posX = 0;
                posY = parseFloat(inputs.h.value);
            }

            // Konwersja na współrzędne Canvas
            // Y w canvas rośnie w dół, więc odejmujemy od wysokości canvasa
            const canvasX = 20 + posX * scale; 
            const canvasY = canvas.height - 20 - posY * scale;

            // Rysuj piłkę
            ctx.beginPath();
            ctx.fillStyle = '#ff4757';
            ctx.arc(canvasX, canvasY, 6, 0, Math.PI * 2);
            ctx.fill();
            ctx.closePath();
        }

        // Pętla animacji
        function animate() {
            if (!state.running) return;

            const v0 = parseFloat(inputs.v.value);
            const angleRad = parseFloat(inputs.angle.value) * (Math.PI / 180);
            const h = parseFloat(inputs.h.value);
            const g = parseFloat(inputs.g.value);
            
            // Krok czasu (delta t)
            const dt = 0.05; 
            state.t += dt;

            // Równania ruchu
            state.x = v0 * Math.cos(angleRad) * state.t;
            state.y = h + (v0 * Math.sin(angleRad) * state.t) - (0.5 * g * state.t * state.t);

            // Zapisz punkt do ścieżki
            state.path.push({x: state.x, y: state.y});

            // Sprawdź czy uderzyła w ziemię
            if (state.y < 0) {
                state.y = 0;
                state.running = false;
                drawScene();
                return; 
            }

            drawScene();
            animationId = requestAnimationFrame(animate);
        }

        // Event Listenery
        Object.values(inputs).forEach(input => {
            input.addEventListener('input', () => {
                if (state.running) return; // Zablokuj zmiany w trakcie lotu
                updateUI();
            });
        });

        document.getElementById('btn-start').addEventListener('click', () => {
            if (state.running) return;
            
            // Resetuj stan przed startem
            state.t = 0;
            state.path = [];
            state.running = true;
            calculateStats();
            animate();
        });

        document.getElementById('btn-reset').addEventListener('click', () => {
            state.running = false;
            cancelAnimationFrame(animationId);
            state.t = 0;
            state.path = [];
            state.x = 0;
            state.y = parseFloat(inputs.h.value);
            updateUI();
        });

        // Inicjalizacja
        updateUI();

    </script>
</body>
</html>